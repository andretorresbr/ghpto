#!/usr/bin/env python3
# Arquivo: /var/ossec/integrations/custom-telegram_windows
#   chmod 750 /var/ossec/integrations/custom-telegram_windows
#   chown root:wazuh /var/ossec/integrations/custom-telegram_windows
# Adicionar a integration no /var/ossec/etc/ossec.conf
# <integration>
#    <name>custom-telegram_windows</name>
#    <hook_url>https://api.telegram.org/botSEU_TOKEN/sendMessage?chat_id=SEU_CHAT_ID</hook_url>
#    <alert_format>json</alert_format>
#    <!-- <rule_id>110002</rule_id> -->
#    <level>12</level>
#  </integration>
#
# Reiniciar o wazuh-manager: systemctl restart wazuh-manager
#

import sys
import json
import requests
from datetime import datetime

# 1. ConfiguraÃ§Ãµes
alert_file = sys.argv[1]
hook_url = sys.argv[3]

# 2. FunÃ§Ãµes Auxiliares

def html_escape(text):
    if not text: return "N/A"
    return str(text).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

def format_date(iso_string):
    try:
        # Tenta converter o padrÃ£o Wazuh para algo legÃ­vel no Brasil
        dt_obj = datetime.strptime(iso_string, "%Y-%m-%dT%H:%M:%S.%f%z")
        return dt_obj.strftime("%d/%m/%Y %H:%M:%S (UTC%z)")
    except Exception:
        return iso_string

# 3. Carregar JSON
with open(alert_file) as f:
    alert_json = json.load(f)

# 4. ExtraÃ§Ã£o e Tratamento de Dados
rule_id = alert_json.get('rule', {}).get('id', 'N/A')
level = alert_json.get('rule', {}).get('level', 'N/A')
agent_name = alert_json.get('agent', {}).get('name', 'N/A')

# Data formatada
raw_timestamp = alert_json.get('timestamp', 'N/A')
timestamp = format_date(raw_timestamp)

# DescriÃ§Ã£o sanitizada
description_raw = alert_json.get('rule', {}).get('description', 'N/A')
description = html_escape(description_raw)

# 5. Log Completo (LÃ³gica Melhorada para Linux/Frequency Rules)
full_message = alert_json.get('data', {}).get('win', {}).get('system', {}).get('message')

# Se nÃ£o for Windows, tenta o log bruto padrÃ£o
if not full_message:
    full_message = alert_json.get('full_log')

# Se AINDA estiver vazio (comum em regras de frequÃªncia/Linux onde o full_log Ã© suprimido),
# vamos extrair os dados decodificados (srcip, dstuser, etc)
if not full_message:
    data_content = alert_json.get('data', {})
    if data_content:
        # Removemos a parte do windows se existir vazia para limpar a visualizaÃ§Ã£o
        data_content.pop('win', None)
        # Formata o dicionÃ¡rio como uma string JSON legÃ­vel
        full_message = json.dumps(data_content, indent=4, ensure_ascii=False)
    else:
        full_message = 'Log bruto indisponÃ­vel'

# Truncagem de seguranÃ§a
if len(str(full_message)) > 3000:
    full_message = str(full_message)[:3000] + "\n\n... [LOG TRUNCADO] ..."

full_message_safe = html_escape(full_message)

# 6. Montagem da Mensagem (HTML)
msg_text = f"""
ğŸš¨ <b>WAZUH AUDIT - NÃVEL {level}</b> ğŸš¨

ğŸ“… <b>Data:</b> <code>{timestamp}</code>
ğŸ›¡ï¸ <b>Regra:</b> <code>{rule_id}</code>

ğŸ“ <b>Alerta:</b> {description}

ğŸ¢ <b>Agente responsÃ¡vel pelo envio do log:</b> <code>{agent_name}</code>

ğŸ“œ <b>Log do Sistema:</b>
<pre>
{full_message_safe}
</pre>

âš ï¸ <i>Verifique imediatamente.</i>
"""

# 7. Envio
try:
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    payload = {
        'text': msg_text,
        'parse_mode': 'HTML'
    }
    requests.post(hook_url, data=payload, headers=headers)
except Exception as e:
    sys.exit(1)

sys.exit(0)
